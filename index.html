<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Wind Data (Robust)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.min.js"></script>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f0f4f8; }
        #map { height: 300px; width: 100%; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); }
        .chart-container { position: relative; height: 350px; }
        .leaflet-popup-content-wrapper { background: #fff; color: #333; }
        .station-list { max-height: 200px; overflow-y: auto; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }
        .live-dot { animation: pulse 1.5s infinite; }
        input[type="checkbox"]:disabled + label { cursor: not-allowed; opacity: 0.5; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Configuration ---
        const API_KEY = "v2:43847eaac104333fa323d3310cf8ef01f27523477c46c12827b6b31426f1ede1:PShUptn2OuGsQx2UmTgemsHrBFGVbg7F";
        const API_BASE = 'https://api-open.data.gov.sg/v2/real-time/api/';
        const CONVERSIONS = { 'knots': 1, 'm/s': 0.514444, 'km/h': 1.852 };
        const KNOT_THRESHOLDS = { SAIL: 15 };
        const SPEED_COLORS = { LEVEL_1: '#ef4444', LEVEL_2: '#f59e0b', LEVEL_3: '#22c55e', LEVEL_4: '#3b82f6' };

        // --- Helpers ---
        const convertSpeed = (val, unit) => (val == null) ? 0 : val * CONVERSIONS[unit];
        const degreesToCardinal = (deg) => {
            if (deg == null) return '';
            const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            return dirs[Math.round(deg / 22.5) % 16];
        };
        const getSpeedColor = (s) => {
            if (s == null) return '#9ca3af';
            if (s < 10) return SPEED_COLORS.LEVEL_1;
            if (s < 20) return SPEED_COLORS.LEVEL_2;
            if (s < 30) return SPEED_COLORS.LEVEL_3;
            return SPEED_COLORS.LEVEL_4;
        };
        const formatTimestamp = (date) => {
            if (!date) return '';
            return `${date.getDate()}/${date.getMonth()+1} @ ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
        };
        // Small delay helper to prevent Rate Limits
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- Chart Plugins ---
        const verticalLinePlugin = {
            id: 'customVerticalLine',
            beforeDatasetsDraw: chart => {
                if (chart.tooltip?._active?.length) {
                    const ctx = chart.ctx;
                    const x = chart.tooltip._active[0].element.x;
                    const topY = chart.scales.y?.top;
                    const bottomY = chart.scales.y?.bottom;
                    if (topY !== undefined) {
                        ctx.save(); ctx.beginPath(); ctx.moveTo(x, topY); ctx.lineTo(x, bottomY);
                        ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; ctx.stroke(); ctx.restore();
                    }
                }
            }
        };

        const northLinePlugin = {
            id: 'northLine',
            afterDraw: chart => {
                const yAxis = chart.scales.y1;
                if (!yAxis || yAxis.id !== 'deg') return;
                const ctx = chart.ctx;
                const area = chart.chartArea;
                if (!area) return;
                const ticks = yAxis.getTicks();
                ticks.forEach(t => {
                    if (t.value % 360 === 0) {
                        const y = yAxis.getPixelForTick(t.index);
                        if(y >= area.top && y <= area.bottom) {
                            ctx.save(); ctx.beginPath(); ctx.moveTo(area.left, y); ctx.lineTo(area.right, y);
                            ctx.lineWidth = 1; ctx.strokeStyle = 'red'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.restore();
                        }
                    }
                });
            }
        };

        // --- Components ---
        const Speedometer = ({ speedKnots }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;
                const cx = width / 2, cy = height - 10, r = width / 2 - 20;
                ctx.clearRect(0,0,width,height);
                const arc = (s, e, c) => { ctx.beginPath(); ctx.arc(cx, cy, r, s, e); ctx.strokeStyle = c; ctx.lineWidth = 12; ctx.stroke(); };
                arc(Math.PI, Math.PI + (Math.PI * 0.25), SPEED_COLORS.LEVEL_1);
                arc(Math.PI + (Math.PI * 0.25), Math.PI + (Math.PI * 0.5), SPEED_COLORS.LEVEL_2);
                arc(Math.PI + (Math.PI * 0.5), Math.PI + (Math.PI * 0.75), SPEED_COLORS.LEVEL_3);
                arc(Math.PI + (Math.PI * 0.75), 2 * Math.PI, SPEED_COLORS.LEVEL_4);
                const angle = Math.PI + (Math.PI * (Math.min(speedKnots || 0, 40) / 40));
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + Math.cos(angle)*(r-5), cy + Math.sin(angle)*(r-5));
                ctx.strokeStyle = '#333'; ctx.lineWidth = 3; ctx.stroke();
            }, [speedKnots]);
            return <canvas ref={canvasRef} width="160" height="90"></canvas>;
        };

        const DirectionArrow = ({ direction, speedKnots }) => (
            <div className="relative w-24 h-24 flex items-center justify-center">
                <div style={{ transform: `rotate(${direction + 180}deg)`, transition: 'transform 0.3s ease-out' }}>
                    <svg width="60" height="60" viewBox="0 0 100 100">
                        <path d="M50 0 L20 40 L40 40 L40 100 L60 100 L60 40 L80 40 Z" fill={getSpeedColor(speedKnots)} stroke="black" strokeWidth="3" strokeLinejoin="round" />
                    </svg>
                </div>
            </div>
        );

        const DirectionAxisControls = ({ onShift, onReset }) => (
            <div className="flex items-center gap-2">
                <button onClick={() => onShift(-45)} className="text-lg bg-gray-200 text-gray-700 w-8 h-8 rounded-full hover:bg-gray-300 shadow">▲</button>
                <button onClick={onReset} className="text-xs bg-gray-200 text-gray-700 px-2 py-1 rounded-md hover:bg-gray-300 shadow">Reset</button>
                <button onClick={() => onShift(45)} className="text-lg bg-gray-200 text-gray-700 w-8 h-8 rounded-full hover:bg-gray-300 shadow">▼</button>
            </div>
        );

        const ChartFilters = ({ selected, onToggle, disabled }) => {
            const metrics = { speed: 'Wind Speed', deg: 'Wind Direction', temp: 'Temperature', humidity: 'Humidity' };
            return (
                <div className="flex flex-wrap gap-x-4 gap-y-2 mb-4">
                    <span className="text-sm font-semibold text-gray-600 self-center">Compare Any 2 Metrics:</span>
                    {Object.keys(metrics).map(key => (
                        <div key={key} className="flex items-center">
                            <input type="checkbox" id={`metric-${key}`} checked={selected.includes(key)} onChange={() => onToggle(key)} disabled={disabled && !selected.includes(key)} className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
                            <label htmlFor={`metric-${key}`} className="ml-2 text-sm text-gray-700">{metrics[key]}</label>
                        </div>
                    ))}
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [allStations, setAllStations] = useState([]);
            const [selectedStation, setSelectedStation] = useState(null);
            
            // Separate Data Streams
            const [liveDataMap, setLiveDataMap] = useState({});
            const [chartHistory, setChartHistory] = useState({});
            
            // UI State
            const [units, setUnits] = useState('knots');
            const [historyStatus, setHistoryStatus] = useState(null);
            const [isZoomed, setIsZoomed] = useState(false);
            const [isStationModalOpen, setStationModalOpen] = useState(false);
            const [directionCenter, setDirectionCenter] = useState(180);
            const [selectedMetrics, setSelectedMetrics] = useState(['speed', 'deg']);
            
            const mapRef = useRef(null);
            const windChartRef = useRef(null);
            const windCanvasRef = useRef(null);

            // 1. Live Data (Immediate)
            useEffect(() => {
                const fetchLive = async () => {
                    try {
                        const headers = { "x-api-key": API_KEY };
                        // Fetch latest snapshots only (no date param)
                        const [speed, deg, temp, humid] = await Promise.all([
                            fetch(`${API_BASE}wind-speed`, { headers }).then(r => r.json()),
                            fetch(`${API_BASE}wind-direction`, { headers }).then(r => r.json()),
                            fetch(`${API_BASE}air-temperature`, { headers }).then(r => r.json()),
                            fetch(`${API_BASE}relative-humidity`, { headers }).then(r => r.json())
                        ]);

                        if (speed.code === 0 && speed.data.stations) {
                            setAllStations(speed.data.stations);
                            setSelectedStation(prev => prev || speed.data.stations.find(s => s.name.includes('East Coast')) || speed.data.stations[0]);

                            const extractMap = (dataset) => {
                                const map = {};
                                if(dataset.data && dataset.data.readings && dataset.data.readings[0]) {
                                    dataset.data.readings[0].data.forEach(r => map[r.stationId] = r.value);
                                    map._time = new Date(dataset.data.readings[0].timestamp);
                                }
                                return map;
                            };
                            
                            const sMap = extractMap(speed);
                            const dMap = extractMap(deg);
                            const tMap = extractMap(temp);
                            const hMap = extractMap(humid);
                            
                            const combined = {};
                            speed.data.stations.forEach(s => {
                                combined[s.id] = {
                                    speed: sMap[s.id], deg: dMap[s.id], temp: tMap[s.id], humidity: hMap[s.id], time: sMap._time
                                };
                            });
                            
                            setLiveDataMap(combined);
                            
                            // Start history fetch after live data is ready
                            fetchHistoryRobust(speed.data.stations);
                        }
                    } catch (e) {
                        console.error("Live fetch error:", e);
                    }
                };
                
                fetchLive();
                const interval = setInterval(fetchLive, 60000);
                return () => clearInterval(interval);
            }, []);

            // 2. Robust History Fetch (Throttled + Independent)
            const fetchHistoryRobust = async (stations) => {
                setHistoryStatus("Loading...");
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                const headers = { "x-api-key": API_KEY };

                // A fetcher that sleeps between pages to avoid 429 errors
                const fetchWithThrottle = async (endpoint) => {
                    let readings = [];
                    let url = `${API_BASE}${endpoint}?date=${dateStr}`;
                    let page = 0;
                    
                    while(url && page < 20) {
                        try {
                            const res = await fetch(url, { headers });
                            if (res.status === 429) {
                                // Hit rate limit? Wait 1s and retry once
                                await sleep(1000);
                                continue;
                            }
                            const json = await res.json();
                            if(json.code !== 0) break;
                            
                            if(json.data.readings) readings.push(...json.data.readings);
                            
                            if(json.data.paginationToken) {
                                url = `${API_BASE}${endpoint}?date=${dateStr}&paginationToken=${encodeURIComponent(json.data.paginationToken)}`;
                                page++;
                                // THROTTLE: Sleep 300ms between pages
                                await sleep(300);
                            } else {
                                url = null;
                            }
                        } catch (err) {
                            console.warn(`Error fetching ${endpoint} page ${page}`, err);
                            break; // Stop fetching this metric, but return what we have
                        }
                    }
                    return readings;
                };

                // Fetch metrics independently (if temp fails, wind still works)
                const [speedRaw, degRaw, tempRaw, humidRaw] = await Promise.all([
                    fetchWithThrottle('wind-speed'),
                    fetchWithThrottle('wind-direction'),
                    fetchWithThrottle('air-temperature'),
                    fetchWithThrottle('relative-humidity')
                ]);

                // Stitch Logic
                const timeMap = {};
                const process = (raw, key) => {
                    if(!raw) return;
                    raw.forEach(batch => {
                        const t = new Date(batch.timestamp).getTime();
                        batch.data.forEach(r => {
                            if(!timeMap[r.stationId]) timeMap[r.stationId] = {};
                            if(!timeMap[r.stationId][t]) timeMap[r.stationId][t] = { time: t };
                            timeMap[r.stationId][t][key] = r.value;
                        });
                    });
                };

                process(speedRaw, 'speed');
                process(degRaw, 'deg');
                process(tempRaw, 'temp');
                process(humidRaw, 'humidity');

                const historyByStation = {};
                stations.forEach(s => {
                    const arr = timeMap[s.id] ? Object.values(timeMap[s.id]) : [];
                    arr.sort((a,b) => a.time - b.time);
                    const cutoff = now.getTime() - (6 * 60 * 60 * 1000);
                    historyByStation[s.id] = arr.filter(d => d.time >= cutoff);
                });

                setChartHistory(historyByStation);
                setHistoryStatus(null);
            };

            // 3. Map & Chart Logic
            useEffect(() => {
                if (isStationModalOpen && !mapRef.current) {
                    setTimeout(() => {
                        const map = L.map('map').setView([1.3521, 103.8198], 11);
                        mapRef.current = map;
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OSM' }).addTo(map);
                        const layer = L.layerGroup().addTo(map);
                        allStations.forEach(s => {
                            const m = L.marker([s.location.latitude, s.location.longitude]).addTo(layer);
                            m.bindTooltip(s.name).on('click', () => { setSelectedStation(s); setStationModalOpen(false); });
                        });
                    }, 100);
                }
                return () => { if (!isStationModalOpen && mapRef.current) { mapRef.current.remove(); mapRef.current = null; } };
            }, [isStationModalOpen, allStations]);

            useEffect(() => {
                const canvas = windCanvasRef.current;
                if (!canvas || !selectedStation) return;
                if (windChartRef.current) { windChartRef.current.destroy(); windChartRef.current = null; }
                setIsZoomed(false);

                const data = chartHistory[selectedStation.id] || [];
                // If we have live data but history failed/is loading, we can at least show the live point? 
                // For now, let's just wait for history.
                
                const metricConfigs = {
                    speed: {
                        key: 'speed', label: `Wind Speed (${units})`, color: 'black', yAxisID: 'y',
                        data: data.map(d => ({ x: d.time, y: convertSpeed(d.speed, units) })),
                        getScale: () => ({ type: 'linear', display: true, position: 'left', beginAtZero: true })
                    },
                    deg: {
                        key: 'deg', label: 'Wind Direction (°)', color: 'red', yAxisID: 'y1',
                        data: data.map(d => {
                            if (d.deg === undefined) return { x: d.time, y: null };
                            let val = d.deg;
                            const diff = val - directionCenter;
                            if (diff > 180) val -= 360;
                            if (diff < -180) val += 360;
                            return { x: d.time, y: val };
                        }),
                        getScale: () => ({
                            id: 'deg', type: 'linear', display: true, position: 'right',
                            min: directionCenter - 180, max: directionCenter + 180,
                            title: { display: true, text: 'Direction (°)' },
                            ticks: { stepSize: 45, callback: v => (Math.round(v / 45) * 45 + 360) % 360 }
                        })
                    },
                    temp: {
                        key: 'temp', label: 'Temperature (°C)', color: 'orange', yAxisID: 'y',
                        data: data.map(d => ({ x: d.time, y: d.temp })),
                        getScale: () => ({ type: 'linear', display: true, position: 'left' })
                    },
                    humidity: {
                        key: 'humidity', label: 'Humidity (%)', color: 'blue', yAxisID: 'y1',
                        data: data.map(d => ({ x: d.time, y: d.humidity })),
                        getScale: () => ({ type: 'linear', display: true, position: 'right', min: 0, max: 100 })
                    }
                };

                const datasets = [];
                const scales = { x: { type: 'time', time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } } } };

                if (selectedMetrics[0]) {
                    const m1 = metricConfigs[selectedMetrics[0]];
                    datasets.push({ label: m1.label, data: m1.data, borderColor: m1.color, yAxisID: 'y', pointRadius: 0, pointHoverRadius: 4 });
                    scales.y = { ...m1.getScale(), position: 'left' };
                }
                if (selectedMetrics[1]) {
                    const m2 = metricConfigs[selectedMetrics[1]];
                    datasets.push({ label: m2.label, data: m2.data, borderColor: m2.color, yAxisID: 'y1', pointRadius: 0, pointHoverRadius: 4, borderDash: m2.key === 'deg' ? [5,5] : [] });
                    scales.y1 = { ...m2.getScale(), position: 'right' };
                }

                windChartRef.current = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales,
                        plugins: {
                            zoom: {
                                pan: { enabled: true, mode: 'x' },
                                zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x', onZoomComplete: () => setIsZoomed(true) }
                            },
                            tooltip: { callbacks: { title: (items) => { const d = new Date(items[0].parsed.x); return `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`; } } }
                        }
                    },
                    plugins: [verticalLinePlugin, northLinePlugin]
                });
            }, [chartHistory, selectedStation, units, directionCenter, selectedMetrics]);

            const handleResetZoom = () => { if (windChartRef.current) { windChartRef.current.resetZoom(); setIsZoomed(false); } };
            const handleAxisShift = (amt) => setDirectionCenter(prev => (prev + amt + 360) % 360);
            const handleMetricToggle = (key) => setSelectedMetrics(prev => prev.includes(key) ? prev.filter(m => m !== key) : (prev.length < 2 ? [...prev, key] : prev));

            const current = (selectedStation && liveDataMap[selectedStation.id]) ? liveDataMap[selectedStation.id] : {};

            return (
                <div className="min-h-screen bg-gray-100 p-4 sm:p-6 lg:p-8">
                    {/* Modal */}
                    {isStationModalOpen && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center" onClick={()=>setStationModalOpen(false)}>
                            <div className="bg-white p-6 rounded-xl shadow-lg w-full max-w-2xl" onClick={e=>e.stopPropagation()}>
                                <h2 className="text-2xl font-semibold mb-4">Select Station</h2>
                                <div id="map"></div>
                                <div className="station-list mt-4 border-t pt-2">
                                    {allStations.sort((a,b)=>a.name.localeCompare(b.name)).map(s => (
                                        <div key={s.id} onClick={()=>{setSelectedStation(s); setStationModalOpen(false)}} className={`p-2 rounded cursor-pointer hover:bg-blue-100 ${selectedStation?.id===s.id ? 'bg-blue-200 font-bold' : ''}`}>
                                            {s.name}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="max-w-7xl mx-auto">
                        <header className="mb-6 flex justify-between items-center">
                            <div>
                                <h1 className="text-2xl font-bold text-gray-800">Live Wind Data</h1>
                                <p className="text-lg text-gray-600 mt-1">Official Data (V2) - Robust</p>
                            </div>
                            <button onClick={()=>setStationModalOpen(true)} className="bg-white px-4 py-2 rounded-lg shadow hover:bg-gray-200 transition font-semibold">
                                {selectedStation ? selectedStation.name : 'Select Station'}
                            </button>
                        </header>

                        {(current.speed > KNOT_THRESHOLDS.SAIL) && (
                            <div className="bg-green-500 text-white text-center font-bold p-4 rounded-lg mb-6 text-xl shadow-lg animate-pulse">
                                Wind is Great! Stop working and start sailing! ⛵
                            </div>
                        )}

                        <div className="flex flex-col gap-8">
                            {/* Card 1: Live */}
                            <div className="bg-white p-6 rounded-xl shadow-lg">
                                <div className="mb-4">
                                    <h2 className="text-2xl font-semibold text-gray-700">
                                        <span className="text-blue-600">{selectedStation?.name || 'Loading...'}</span>
                                    </h2>
                                    <div className="flex items-center gap-2 text-sm text-gray-500 mt-1">
                                        <div className="w-3 h-3 bg-red-500 rounded-full live-dot"></div>
                                        <span>{current.time ? formatTimestamp(current.time) : 'Connecting...'}</span>
                                    </div>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="p-4 bg-gray-50 rounded-lg">
                                        <div className="grid grid-cols-2 gap-4">
                                            <div className="flex flex-col items-center">
                                                <div className="text-center mb-2">
                                                    <div className="text-xs text-gray-500">Direction</div>
                                                    <div className="text-xl font-bold">{current.deg !== undefined ? current.deg + '° ' + degreesToCardinal(current.deg) : '-'}</div>
                                                </div>
                                                <DirectionArrow direction={current.deg || 0} speedKnots={current.speed} />
                                            </div>
                                            <div className="flex flex-col items-center">
                                                <div className="text-center mb-2">
                                                    <div className="text-xs text-gray-500">Speed</div>
                                                    <div className="text-xl font-bold">{convertSpeed(current.speed, units).toFixed(1)} <small>{units}</small></div>
                                                </div>
                                                <Speedometer speedKnots={current.speed} />
                                            </div>
                                        </div>
                                        <div className="flex justify-center mt-4 space-x-1 rounded-lg bg-gray-200 p-1">
                                            {Object.keys(CONVERSIONS).map(u => <button key={u} onClick={()=>setUnits(u)} className={`px-3 py-1 text-sm font-semibold rounded-md transition ${units===u ? 'bg-white text-blue-600 shadow' : 'text-gray-600'}`}>{u}</button>)}
                                        </div>
                                    </div>
                                    <div className="p-4 bg-gray-50 rounded-lg flex flex-col justify-center items-center">
                                        <div className="text-center text-xs text-gray-500">Live Conditions</div>
                                        <div className="flex items-center gap-6 mt-4">
                                            <div className="text-center">
                                                <svg className="w-10 h-10 mx-auto text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16V6a1 1 0 00-1-1H9a1 1 0 00-1 1v10a5 5 0 0010 0v-2.5a.5.5 0 00-.5-.5h-1a.5.5 0 00-.5.5V16a3 3 0 01-6 0z"></path><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 4a1 1 0 011-1h2a1 1 0 011 1v1a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z"></path></svg>
                                                <div className="text-2xl font-bold mt-2">{current.temp ? current.temp.toFixed(1) + '°C' : '-'}</div>
                                                <div className="text-xs text-gray-500">Temperature</div>
                                            </div>
                                            <div className="text-center">
                                                <svg className="w-10 h-10 mx-auto text-cyan-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.8M9 19l3 3m0 0l3-3m-3 3V10"></path></svg>
                                                <div className="text-2xl font-bold mt-2">{current.humidity ? current.humidity.toFixed(0) + '%' : '-'}</div>
                                                <div className="text-xs text-gray-500">Humidity</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* Card 2: History */}
                            <div className="bg-white p-6 rounded-xl shadow-lg">
                                <div className="flex justify-between items-center mb-4">
                                    <h3 className="text-lg font-semibold text-gray-700">
                                        6-Hour History
                                        {historyStatus && <span className="ml-2 text-xs text-blue-500 font-normal animate-pulse">({historyStatus})</span>}
                                    </h3>
                                    {selectedMetrics.includes('deg') && <DirectionAxisControls onShift={handleAxisShift} onReset={() => setDirectionCenter(180)} />}
                                    {isZoomed && <button onClick={handleResetZoom} className="text-sm bg-blue-500 text-white py-1 px-3 rounded-lg hover:bg-blue-600 transition">Reset Zoom</button>}
                                </div>
                                <ChartFilters selected={selectedMetrics} onToggle={handleMetricToggle} disabled={selectedMetrics.length >= 2} />
                                <div className="chart-container">
                                    <canvas ref={windCanvasRef}></canvas>
                                </div>
                            </div>

                            {/* Card 3: About */}
                            <div className="bg-white p-6 rounded-xl shadow-lg">
                                <h3 className="text-lg font-semibold text-gray-700 mb-4">About The Data</h3>
                                <ul className="space-y-2 text-sm text-gray-600">
                                    <li><p>This application displays real-time wind data sourced directly from the National Environment Agency (NEA) via data.gov.sg (V2 API).</p></li>
                                    <li><p><strong>Update Frequency:</strong> Data is typically updated every 5 minutes.</p></li>
                                </ul>
                                <div className="mt-4 pt-4 border-t">
                                     <a href="https://data.gov.sg/collections/1459/view" target="_blank" rel="noopener noreferrer" className="text-sm text-blue-600 hover:underline">
                                         Reference: https://data.gov.sg/collections/1459/view
                                     </a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
